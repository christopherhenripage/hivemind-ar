<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gallery - HiveMind AR</title>
  <link rel="stylesheet" href="/styles/hivemind.css">

  <!-- Model-Viewer for AR - using jsdelivr (more reliable than unpkg) -->
  <script type="module" src="https://cdn.jsdelivr.net/npm/@google/model-viewer@3.3.0/dist/model-viewer.min.js"></script>
  <!-- Fallback if jsdelivr fails -->
  <script type="module">
    if (!customElements.get('model-viewer')) {
      const script = document.createElement('script');
      script.type = 'module';
      script.src = 'https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js';
      document.head.appendChild(script);
    }
  </script>

  <style>
    .artist-hero {
      background: var(--hm-dark);
      padding: 8rem 2rem 4rem;
      text-align: center;
      color: var(--hm-white);
    }

    .artist-avatar {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      object-fit: cover;
      border: 4px solid rgba(255,255,255,0.2);
      margin-bottom: 1.5rem;
    }

    .artist-name-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .artist-hero h1 {
      font-size: 2.5rem;
      font-weight: 300;
      margin-bottom: 0;
    }

    .verified-badge {
      display: inline-flex;
      align-items: center;
      animation: badgePulse 3s ease-in-out infinite;
    }

    .verified-badge svg {
      filter: drop-shadow(0 0 6px rgba(212, 175, 55, 0.6));
    }

    @keyframes badgePulse {
      0%, 100% {
        transform: scale(1);
        filter: drop-shadow(0 0 4px rgba(212, 175, 55, 0.4));
      }
      50% {
        transform: scale(1.1);
        filter: drop-shadow(0 0 8px rgba(212, 175, 55, 0.8));
      }
    }

    .artist-location {
      opacity: 0.7;
      margin-bottom: 1rem;
    }

    .artist-bio {
      max-width: 600px;
      margin: 0 auto;
      opacity: 0.9;
      line-height: 1.6;
    }

    .artist-links {
      margin-top: 1.5rem;
      display: flex;
      justify-content: center;
      gap: 1rem;
    }

    .artist-links a {
      color: white;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    .artist-links a:hover {
      opacity: 1;
    }

    /* Banner styles */
    .artist-banner {
      width: 100%;
      height: 300px;
      overflow: hidden;
    }

    .artist-banner img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center 50%;
    }

    .artist-hero.has-banner {
      padding-top: 4rem;
    }

    /* Social links */
    .social-links {
      display: flex;
      justify-content: center;
      gap: 0.75rem;
      margin-top: 1rem;
    }

    .social-link {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      background: rgba(255,255,255,0.1);
      border-radius: 50%;
      color: white;
      text-decoration: none;
      font-size: 1.2rem;
      transition: background 0.2s, transform 0.2s;
    }

    .social-link:hover {
      background: rgba(255,255,255,0.2);
      transform: scale(1.1);
    }

    .gallery-stats {
      display: flex;
      justify-content: center;
      gap: 3rem;
      margin-top: 2rem;
      padding-top: 2rem;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .gallery-stat {
      text-align: center;
    }

    .gallery-stat .value {
      font-size: 1.5rem;
      font-weight: 600;
    }

    .gallery-stat .label {
      font-size: 0.8rem;
      opacity: 0.7;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .gallery-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 3rem 2rem;
    }

    .artwork-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 2rem;
    }

    .artwork-card {
      background: var(--hm-white);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .artwork-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 30px rgba(0,0,0,0.12);
    }

    .artwork-card model-viewer {
      width: 100%;
      height: 300px;
      background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
    }

    .artwork-card model-viewer::part(default-ar-button) {
      position: absolute;
      bottom: 10px;
      right: 10px;
      opacity: 0;
      pointer-events: all;
      z-index: 1;
    }

    .artwork-card-wrapper {
      position: relative;
    }

    .custom-ar-button {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 1rem 2rem;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: all 0.3s;
      z-index: 10;
    }

    .custom-ar-button:hover {
      transform: translateX(-50%) scale(1.05);
      box-shadow: 0 6px 30px rgba(102, 126, 234, 0.6);
    }

    .custom-ar-button:active {
      transform: translateX(-50%) scale(0.98);
    }

    .custom-ar-button::before {
      content: 'üì±';
      font-size: 1.5rem;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .custom-ar-button.pulse {
      animation: pulse 2s infinite;
    }

    /* Frame Selector - Compact inline version */
    .frame-selector-compact {
      position: absolute;
      bottom: 85px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 0.5rem;
      display: flex;
      gap: 0.5rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      z-index: 5;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s, bottom 0.3s;
    }

    .artwork-card-wrapper:hover .frame-selector-compact {
      opacity: 1;
      pointer-events: all;
      bottom: 90px;
    }

    .frame-btn {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      border: 3px solid transparent;
      cursor: pointer;
      transition: all 0.2s;
      background: #f5f5f5;
      position: relative;
    }

    .frame-btn:hover {
      transform: scale(1.1);
      border-color: #999;
    }

    .frame-btn.selected {
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.3);
    }

    .frame-btn::before {
      content: '';
      position: absolute;
      inset: 4px;
      border-radius: 4px;
      background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
    }

    .frame-btn.no-frame::before {
      border: 2px dashed #ccc;
      background: white;
    }

    .frame-btn.wood-frame::before {
      border: 4px solid #8B4513;
    }

    .frame-btn.black-frame::before {
      border: 4px solid #1a1a1a;
    }

    .frame-btn.gold-frame::before {
      border: 4px solid #C9A227;
      box-shadow: 0 0 5px rgba(201, 162, 39, 0.5);
    }

    .frame-btn.white-frame::before {
      border: 4px solid #f8f8f8;
    }

    .frame-btn.silver-frame::before {
      border: 4px solid #c0c0c0;
    }

    .artwork-card .artwork-image {
      width: 100%;
      height: 300px;
      object-fit: cover;
      background: var(--hm-light-gray);
    }

    .artwork-info {
      padding: 1.25rem;
    }

    .ar-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      background: var(--hm-dark);
      color: var(--hm-white);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.5rem;
    }

    .artwork-info h3 {
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
      color: var(--hm-text);
    }

    .artwork-info .description {
      font-size: 0.9rem;
      color: var(--hm-text-light);
      margin-bottom: 0.75rem;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .artwork-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 0.75rem;
      border-top: 1px solid var(--hm-light-gray);
    }

    .artwork-meta .dimensions {
      font-size: 0.8rem;
      color: var(--hm-text-muted);
    }

    .artwork-meta .price {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--hm-text);
    }

    .artwork-actions {
      padding: 0 1.25rem 1.25rem;
      display: flex;
      gap: 0.5rem;
    }

    .artwork-actions .btn {
      flex: 1;
      font-size: 0.85rem;
      padding: 0.6rem;
    }

    .contact-section {
      background: var(--hm-light-gray);
      padding: 4rem 2rem;
      text-align: center;
    }

    .contact-section h2 {
      font-size: 1.75rem;
      font-weight: 300;
      margin-bottom: 1rem;
    }

    .contact-section p {
      color: var(--hm-text-light);
      margin-bottom: 2rem;
    }

    .empty-gallery {
      text-align: center;
      padding: 4rem 2rem;
      color: var(--hm-text-muted);
    }

    .loading {
      text-align: center;
      padding: 4rem 2rem;
      color: var(--hm-text-muted);
    }

    /* AR Helper Section (for free tier - compact banner style) */
    .ar-helper {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-bottom: 1px solid var(--hm-border);
      padding: 0.75rem 1.5rem;
      text-align: center;
    }

    .ar-helper-title {
      font-size: 0.9rem;
      margin: 0 0 0.5rem 0;
      color: var(--hm-dark);
    }

    .ar-helper-title strong {
      color: var(--hm-primary);
    }

    .ar-helper-steps {
      display: flex;
      justify-content: center;
      gap: 1.5rem;
      font-size: 0.8rem;
      color: var(--hm-text-muted);
      margin-bottom: 0.5rem;
    }

    .ar-helper-step {
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .ar-helper-step-num {
      background: var(--hm-primary);
      color: white;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.65rem;
      font-weight: 600;
    }

    .ar-helper-branding {
      font-size: 0.7rem;
    }

    .ar-helper-branding a {
      color: var(--hm-text-muted);
      text-decoration: none;
    }

    .ar-helper-branding strong {
      background: linear-gradient(90deg, #C9A227, #667eea);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* Desktop AR button tooltip */
    .ar-desktop-tooltip {
      display: none;
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #1a1a1a;
      color: white;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      font-size: 0.75rem;
      white-space: nowrap;
      margin-bottom: 8px;
      z-index: 10;
    }

    .ar-desktop-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: #1a1a1a;
    }

    .custom-ar-button:hover .ar-desktop-tooltip {
      display: block;
    }

    .custom-ar-button.desktop-mode {
      position: relative;
    }

    @media (max-width: 768px) {
      .ar-helper {
        padding: 0.75rem 1rem;
      }

      .ar-helper-title {
        font-size: 0.85rem;
      }

      .ar-helper-steps {
        gap: 0.75rem;
        font-size: 0.75rem;
      }
    }

    @media (max-width: 480px) {
      .ar-helper-steps {
        flex-direction: column;
        gap: 0.35rem;
      }
    }

    /* Powered by HiveMind badge */
    .powered-by-badge {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: linear-gradient(135deg, #1a1a1a 0%, #333 100%);
      padding: 0.5rem 1rem;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 100;
    }

    .powered-by-badge a {
      color: white;
      text-decoration: none;
      font-size: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .powered-by-badge strong {
      background: linear-gradient(90deg, #C9A227, #667eea);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    @media (max-width: 768px) {
      .powered-by-badge {
        bottom: 10px;
        right: 10px;
        padding: 0.4rem 0.75rem;
      }
    }

    /* Contact Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 200;
      justify-content: center;
      align-items: center;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: white;
      border-radius: 12px;
      padding: 2rem;
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    .modal-header h2 {
      font-size: 1.25rem;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--hm-text-muted);
    }

    @media (max-width: 768px) {
      .frame-selector-compact {
        opacity: 1;
        pointer-events: all;
        bottom: 85px;
      }

      .frame-btn {
        width: 36px;
        height: 36px;
      }

      .custom-ar-button {
        padding: 0.8rem 1.5rem;
        font-size: 0.9rem;
      }

      .artist-hero {
        padding: 6rem 1.5rem 3rem;
      }

      .artist-hero h1 {
        font-size: 2rem;
      }

      .gallery-stats {
        gap: 1.5rem;
      }

      .gallery-container {
        padding: 2rem 1rem;
      }

      .artwork-grid {
        grid-template-columns: 1fr;
        gap: 1.5rem;
      }

      .artwork-card model-viewer,
      .artwork-card .artwork-image {
        height: 280px;
      }
    }
  </style>
</head>
<body>
  <!-- Navigation -->
  <nav class="public-nav">
    <a href="/" class="logo">
      <img src="https://media.hivemindar.com/images/common/mini_hivemind_logo_white.png" alt="HiveMind AR">
    </a>
    <button class="nav-toggle" onclick="toggleMobileNav()">‚ò∞</button>
    <div class="nav-links" id="navLinks">
      <a href="/">Home</a>
      <a href="/pages/gallery/">Gallery</a>
      <a href="/pages/public/about.html">About</a>
      <a href="/pages/public/contact.html">Contact</a>
    </div>
  </nav>

  <!-- Artist Banner -->
  <div class="artist-banner" id="artistBanner" style="display: none;">
    <img id="bannerImage" src="" alt="Gallery Banner">
  </div>

  <!-- Artist Hero -->
  <section class="artist-hero" id="artistHero">
    <img id="artistAvatar" class="artist-avatar" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='50' fill='%23e2e8f0'/%3E%3Ccircle cx='50' cy='40' r='18' fill='%2394a3b8'/%3E%3Cellipse cx='50' cy='85' rx='30' ry='25' fill='%2394a3b8'/%3E%3C/svg%3E" alt="Artist" style="display: none;">
    <div class="artist-name-row">
      <h1 id="artistName">Loading...</h1>
      <span class="verified-badge" id="verifiedBadge" style="display: none;" title="Verified Artist">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="12" cy="12" r="10" fill="url(#verifiedGradient)"/>
          <path d="M9 12l2 2 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <defs>
            <linearGradient id="verifiedGradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:#C9A227"/>
              <stop offset="50%" style="stop-color:#D4AF37"/>
              <stop offset="100%" style="stop-color:#C9A227"/>
            </linearGradient>
          </defs>
        </svg>
      </span>
    </div>
    <p class="artist-location" id="artistLocation"></p>
    <p class="artist-bio" id="artistBio"></p>
    <div class="artist-links" id="artistLinks"></div>
    <div class="social-links" id="socialLinks"></div>
    <div class="gallery-stats">
      <div class="gallery-stat">
        <div class="value" id="artworkCount">0</div>
        <div class="label">Artworks</div>
      </div>
      <div class="gallery-stat">
        <div class="value" id="viewCount">0</div>
        <div class="label">Views</div>
      </div>
    </div>
  </section>

  <!-- AR Helper Section (shown for free tier) -->
  <div id="arHelper" class="ar-helper" style="display: none;">
    <p class="ar-helper-title">
      üì± <strong>View in AR</strong> ‚Äî See artwork in your space using your phone's camera
    </p>
    <div class="ar-helper-steps">
      <span class="ar-helper-step"><span class="ar-helper-step-num">1</span> Open on mobile</span>
      <span class="ar-helper-step"><span class="ar-helper-step-num">2</span> Tap "View in AR"</span>
      <span class="ar-helper-step"><span class="ar-helper-step-num">3</span> Point at wall</span>
    </div>
    <div class="ar-helper-branding">
      <a href="/" target="_blank">Powered by <strong>HiveMind AR</strong></a>
    </div>
  </div>

  <!-- Artwork Grid -->
  <div class="gallery-container">
    <div class="artwork-grid" id="artworkGrid">
      <div class="loading">Loading artworks...</div>
    </div>
  </div>

  <!-- Contact Section -->
  <section class="contact-section" id="contactSection" style="display: none;">
    <h2>Interested in a piece?</h2>
    <p>Contact the artist directly to inquire about availability and pricing.</p>
    <button class="btn btn-dark" onclick="showContactModal()">Contact Artist</button>
  </section>

  <!-- Powered by HiveMind AR badge (shown for free tier) -->
  <div id="poweredByBadge" class="powered-by-badge" style="display: none;">
    <a href="/" target="_blank">
      Powered by <strong>HiveMind AR</strong>
    </a>
  </div>

  <!-- Footer -->
  <footer class="public-footer">
    <div class="footer-links">
      <a href="/">Home</a>
      <a href="/pages/public/how-it-works.html">How It Works</a>
      <a href="/pages/public/about.html">About</a>
      <a href="/pages/public/contact.html">Contact</a>
    </div>
    <p class="copyright">&copy; 2026 HiveMind AR.</p>
  </footer>

  <!-- Contact Modal -->
  <div class="modal-overlay" id="contactModal">
    <div class="modal">
      <div class="modal-header">
        <h2>Contact Artist</h2>
        <button class="modal-close" onclick="hideContactModal()">&times;</button>
      </div>
      <form id="contactForm" onsubmit="handleContact(event)">
        <div class="form-group">
          <label>Your Name</label>
          <input type="text" id="contactName" class="form-control" required>
        </div>
        <div class="form-group">
          <label>Your Email</label>
          <input type="email" id="contactEmail" class="form-control" required>
        </div>
        <div class="form-group">
          <label>Subject</label>
          <input type="text" id="contactSubject" class="form-control" required>
        </div>
        <div class="form-group">
          <label>Message</label>
          <textarea id="contactMessage" class="form-control" rows="4" required></textarea>
        </div>
        <input type="hidden" id="contactArtworkId">
        <p class="error-text" id="contactError"></p>
        <p id="contactSuccess" style="color: var(--hm-success); text-align: center;"></p>
        <button type="submit" class="btn btn-dark btn-block" id="contactSubmitBtn">Send Message</button>
      </form>
    </div>
  </div>

  <script type="module">
    import { supabase } from '/src/supabase.js';

    // Simple 2D Frame Generator using Canvas
    class SimpleFrameGenerator {
      constructor() {
        this.frameCache = {};
      }

      // Add 2D frame to an image
      async addFrameToImage(imageUrl, frameStyle) {
        const cacheKey = `${imageUrl}_${frameStyle}`;

        // Return cached version if available
        if (this.frameCache[cacheKey]) {
          return this.frameCache[cacheKey];
        }

        // Try multiple methods to load the image
        return this.loadImageWithFallback(imageUrl).then(img => {
          try {
            // Create canvas
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Calculate frame thickness (8% of smallest dimension)
            const frameThickness = Math.min(img.width, img.height) * 0.08;

            // Set canvas size (image + frame)
            canvas.width = img.width + (frameThickness * 2);
            canvas.height = img.height + (frameThickness * 2);

            // Get frame style
            const style = this.getFrameStyle(frameStyle);

            // Draw frame background
            ctx.fillStyle = style.color;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add frame texture/pattern if specified
            if (style.pattern) {
              this.addFramePattern(ctx, canvas.width, canvas.height, style);
            }

            // Draw inner shadow for depth
            if (style.shadow) {
              ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
              ctx.shadowBlur = frameThickness * 0.3;
              ctx.shadowOffsetX = 0;
              ctx.shadowOffsetY = 0;
            }

            // Draw the artwork image in the center
            ctx.drawImage(img, frameThickness, frameThickness, img.width, img.height);

            // Add inner bevel effect
            this.addBevelEffect(ctx, frameThickness, canvas.width, canvas.height, style);

            // Convert to data URL
            const framedImageUrl = canvas.toDataURL('image/png');

            // Cache it
            this.frameCache[cacheKey] = framedImageUrl;

            return framedImageUrl;
          } catch (err) {
            throw new Error(`Canvas processing failed: ${err.message}`);
          }
        });
      }

      // Load image with multiple fallback methods
      async loadImageWithFallback(imageUrl) {
        console.log('Attempting to load image:', imageUrl);

        // Method 1: Try fetch with blob (works for same-origin and CORS-enabled)
        try {
          console.log('Method 1: Trying fetch with blob...');
          const response = await fetch(imageUrl);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const blob = await response.blob();
          const blobUrl = URL.createObjectURL(blob);

          const img = await new Promise((resolve, reject) => {
            const image = new Image();
            image.onload = () => {
              URL.revokeObjectURL(blobUrl);
              resolve(image);
            };
            image.onerror = () => {
              URL.revokeObjectURL(blobUrl);
              reject(new Error('Image load failed'));
            };
            image.src = blobUrl;
          });

          console.log('Method 1 succeeded');
          return img;
        } catch (err) {
          console.log('Method 1 failed:', err.message);
        }

        // Method 2: Try direct load with crossOrigin (works if CORS headers present)
        try {
          console.log('Method 2: Trying direct load with crossOrigin...');
          const img = await new Promise((resolve, reject) => {
            const image = new Image();
            image.crossOrigin = 'anonymous';
            image.onload = () => resolve(image);
            image.onerror = () => reject(new Error('Image load failed'));
            image.src = imageUrl;
          });

          console.log('Method 2 succeeded');
          return img;
        } catch (err) {
          console.log('Method 2 failed:', err.message);
        }

        // Method 3: Try without crossOrigin (tainted canvas, but might work for display)
        try {
          console.log('Method 3: Trying direct load without crossOrigin...');
          const img = await new Promise((resolve, reject) => {
            const image = new Image();
            image.onload = () => resolve(image);
            image.onerror = () => reject(new Error('Image load failed'));
            image.src = imageUrl;
          });

          console.log('Method 3 succeeded (canvas will be tainted)');
          return img;
        } catch (err) {
          console.log('Method 3 failed:', err.message);
        }

        // Method 4: Create a placeholder canvas as fallback
        console.log('Method 4: Creating placeholder canvas...');
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 800;
        const ctx = canvas.getContext('2d');

        // Create a gradient background
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#667eea');
        gradient.addColorStop(1, '#764ba2');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Add text
        ctx.fillStyle = 'white';
        ctx.font = 'bold 48px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('HiveMind AR', canvas.width / 2, canvas.height / 2 - 30);
        ctx.font = '24px sans-serif';
        ctx.fillText('Artwork Preview', canvas.width / 2, canvas.height / 2 + 30);

        // Convert canvas to image
        return new Promise((resolve) => {
          const dataUrl = canvas.toDataURL('image/png');
          const img = new Image();
          img.onload = () => resolve(img);
          img.src = dataUrl;
        });
      }

      // Get frame style properties
      getFrameStyle(style) {
        const styles = {
          wood: {
            color: '#8B4513',
            pattern: 'wood',
            shadow: true
          },
          black: {
            color: '#1a1a1a',
            pattern: null,
            shadow: true
          },
          gold: {
            color: '#C9A227',
            pattern: 'metallic',
            shadow: true
          },
          white: {
            color: '#f8f8f8',
            pattern: null,
            shadow: true
          },
          silver: {
            color: '#c0c0c0',
            pattern: 'metallic',
            shadow: true
          }
        };

        return styles[style] || { color: '#808080', pattern: null, shadow: false };
      }

      // Add pattern to frame
      addFramePattern(ctx, width, height, style) {
        if (style.pattern === 'wood') {
          // Add wood grain texture
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
          ctx.lineWidth = 2;
          for (let i = 0; i < width; i += 20) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i + Math.random() * 10, height);
            ctx.stroke();
          }
        } else if (style.pattern === 'metallic') {
          // Add metallic shine
          const gradient = ctx.createLinearGradient(0, 0, width, height);
          gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
          gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)');
          gradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, width, height);
        }
      }

      // Add bevel effect for depth
      addBevelEffect(ctx, frameThickness, width, height, style) {
        const bevelSize = frameThickness * 0.2;

        // Highlight (top-left)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = bevelSize;
        ctx.strokeRect(bevelSize / 2, bevelSize / 2, width - bevelSize, height - bevelSize);

        // Shadow (bottom-right)
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = bevelSize;
        ctx.strokeRect(
          frameThickness - bevelSize / 2,
          frameThickness - bevelSize / 2,
          width - frameThickness * 2 + bevelSize,
          height - frameThickness * 2 + bevelSize
        );
      }

      // Generate a simple GLB file from a framed image for AR display
      async generateGLBFromImage(framedImageDataUrl, widthInches, heightInches) {
        // Convert inches to meters for AR (1 inch = 0.0254 meters)
        const widthMeters = widthInches * 0.0254;
        const heightMeters = heightInches * 0.0254;

        // Create a simple plane geometry with the image as texture
        // This uses a minimal glTF 2.0 structure
        const imageBase64 = framedImageDataUrl.split(',')[1];
        const imageBytes = atob(imageBase64);
        const imageBuffer = new Uint8Array(imageBytes.length);
        for (let i = 0; i < imageBytes.length; i++) {
          imageBuffer[i] = imageBytes.charCodeAt(i);
        }

        // Create a simple plane geometry
        const positions = new Float32Array([
          -widthMeters/2, -heightMeters/2, 0,
          widthMeters/2, -heightMeters/2, 0,
          widthMeters/2, heightMeters/2, 0,
          -widthMeters/2, heightMeters/2, 0
        ]);

        const normals = new Float32Array([
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
          0, 0, 1
        ]);

        const texCoords = new Float32Array([
          0, 1,
          1, 1,
          1, 0,
          0, 0
        ]);

        const indices = new Uint16Array([
          0, 1, 2,
          0, 2, 3
        ]);

        // Combine all buffers
        const positionsBytes = new Uint8Array(positions.buffer);
        const normalsBytes = new Uint8Array(normals.buffer);
        const texCoordsBytes = new Uint8Array(texCoords.buffer);
        const indicesBytes = new Uint8Array(indices.buffer);

        // Calculate buffer offsets
        let offset = 0;
        const positionsOffset = offset;
        offset += positionsBytes.length;

        // Align to 4 bytes
        while (offset % 4 !== 0) offset++;
        const normalsOffset = offset;
        offset += normalsBytes.length;

        while (offset % 4 !== 0) offset++;
        const texCoordsOffset = offset;
        offset += texCoordsBytes.length;

        while (offset % 4 !== 0) offset++;
        const indicesOffset = offset;
        offset += indicesBytes.length;

        while (offset % 4 !== 0) offset++;
        const imageOffset = offset;

        const totalBufferSize = imageOffset + imageBuffer.length;

        // Create combined buffer
        const combinedBuffer = new Uint8Array(totalBufferSize);
        combinedBuffer.set(positionsBytes, positionsOffset);
        combinedBuffer.set(normalsBytes, normalsOffset);
        combinedBuffer.set(texCoordsBytes, texCoordsOffset);
        combinedBuffer.set(indicesBytes, indicesOffset);
        combinedBuffer.set(imageBuffer, imageOffset);

        // Create glTF JSON
        const gltf = {
          asset: { version: "2.0" },
          scene: 0,
          scenes: [{ nodes: [0] }],
          nodes: [{ mesh: 0 }],
          meshes: [{
            primitives: [{
              attributes: {
                POSITION: 0,
                NORMAL: 1,
                TEXCOORD_0: 2
              },
              indices: 3,
              material: 0
            }]
          }],
          materials: [{
            pbrMetallicRoughness: {
              baseColorTexture: { index: 0 },
              metallicFactor: 0,
              roughnessFactor: 1
            },
            doubleSided: true
          }],
          textures: [{ source: 0 }],
          images: [{
            mimeType: "image/png",
            bufferView: 4
          }],
          accessors: [
            {
              bufferView: 0,
              componentType: 5126,
              count: 4,
              type: "VEC3",
              max: [widthMeters/2, heightMeters/2, 0],
              min: [-widthMeters/2, -heightMeters/2, 0]
            },
            {
              bufferView: 1,
              componentType: 5126,
              count: 4,
              type: "VEC3"
            },
            {
              bufferView: 2,
              componentType: 5126,
              count: 4,
              type: "VEC2"
            },
            {
              bufferView: 3,
              componentType: 5123,
              count: 6,
              type: "SCALAR"
            }
          ],
          bufferViews: [
            { buffer: 0, byteOffset: positionsOffset, byteLength: positionsBytes.length },
            { buffer: 0, byteOffset: normalsOffset, byteLength: normalsBytes.length },
            { buffer: 0, byteOffset: texCoordsOffset, byteLength: texCoordsBytes.length },
            { buffer: 0, byteOffset: indicesOffset, byteLength: indicesBytes.length },
            { buffer: 0, byteOffset: imageOffset, byteLength: imageBuffer.length }
          ],
          buffers: [{ byteLength: totalBufferSize }]
        };

        // Create GLB file
        const gltfJson = JSON.stringify(gltf);
        const gltfJsonBytes = new TextEncoder().encode(gltfJson);

        // Pad JSON to 4-byte alignment
        const gltfJsonPadded = new Uint8Array(Math.ceil(gltfJsonBytes.length / 4) * 4);
        gltfJsonPadded.set(gltfJsonBytes);
        for (let i = gltfJsonBytes.length; i < gltfJsonPadded.length; i++) {
          gltfJsonPadded[i] = 0x20; // Space character for padding
        }

        // GLB header
        const headerSize = 12;
        const jsonChunkHeader = 8;
        const binChunkHeader = 8;
        const totalSize = headerSize + jsonChunkHeader + gltfJsonPadded.length + binChunkHeader + combinedBuffer.length;

        const glb = new Uint8Array(totalSize);
        const view = new DataView(glb.buffer);

        // GLB header
        view.setUint32(0, 0x46546C67, true); // 'glTF' magic
        view.setUint32(4, 2, true); // version
        view.setUint32(8, totalSize, true); // total length

        // JSON chunk header
        let offset2 = 12;
        view.setUint32(offset2, gltfJsonPadded.length, true); // chunk length
        view.setUint32(offset2 + 4, 0x4E4F534A, true); // 'JSON' type
        glb.set(gltfJsonPadded, offset2 + 8);

        // BIN chunk header
        offset2 += 8 + gltfJsonPadded.length;
        view.setUint32(offset2, combinedBuffer.length, true); // chunk length
        view.setUint32(offset2 + 4, 0x004E4942, true); // 'BIN\0' type
        glb.set(combinedBuffer, offset2 + 8);

        // Create blob and object URL
        const blob = new Blob([glb], { type: 'model/gltf-binary' });
        return URL.createObjectURL(blob);
      }
    }

    // Initialize frame generator
    const frameGenerator = new SimpleFrameGenerator();
    window.frameGenerator = frameGenerator;

    // Frame selection state - track per artwork
    const artworkFrameSelections = {};
    const originalPosters = {}; // Store original poster URLs
    const originalGLBs = {}; // Store original GLB URLs
    const framedGLBs = {}; // Store generated framed GLB URLs

    let currentArtist = null;
    let currentPlan = null;
    let artworks = [];

    // Get slug from URL - supports both query param and clean URL formats
    function getSlug() {
      // First try query parameter: /pages/gallery/artist.html?slug=xxx
      const params = new URLSearchParams(window.location.search);
      const querySlug = params.get('slug');
      if (querySlug) return querySlug;

      // Then try clean URL format: /gallery/xxx
      const pathMatch = window.location.pathname.match(/^\/gallery\/([^\/]+)\/?$/);
      if (pathMatch) return pathMatch[1];

      return null;
    }

    // Analytics tracking
    function getSessionId() {
      let sessionId = sessionStorage.getItem('hm_session_id');
      if (!sessionId) {
        sessionId = 'sess_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        sessionStorage.setItem('hm_session_id', sessionId);
      }
      return sessionId;
    }

    function getVisitorFingerprint() {
      let fp = localStorage.getItem('hm_visitor_fp');
      if (!fp) {
        fp = 'v_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        localStorage.setItem('hm_visitor_fp', fp);
      }
      return fp;
    }

    function getDeviceType() {
      const ua = navigator.userAgent;
      if (/tablet|ipad|playbook|silk/i.test(ua)) return 'tablet';
      if (/mobile|iphone|ipod|android|blackberry|opera mini|iemobile/i.test(ua)) return 'mobile';
      return 'desktop';
    }

    async function trackAnalytics(artistId, eventType, artworkId = null) {
      try {
        await supabase.from('gallery_analytics').insert({
          artist_id: artistId,
          event_type: eventType,
          artwork_id: artworkId,
          session_id: getSessionId(),
          visitor_fingerprint: getVisitorFingerprint(),
          referrer: document.referrer || null,
          user_agent: navigator.userAgent,
          device_type: getDeviceType()
        });
      } catch (err) {
        console.log('Analytics tracking error:', err);
      }
    }

    // Load gallery
    async function loadGallery() {
      const slug = getSlug();

      if (!slug) {
        document.getElementById('artistName').textContent = 'Gallery Not Found';
        document.getElementById('artworkGrid').innerHTML = '<div class="empty-gallery">No gallery slug provided.</div>';
        return;
      }

      // Get artist profile with subscription plan
      const { data: artist, error } = await supabase
        .from('profiles')
        .select('*')
        .eq('gallery_slug', slug)
        .eq('is_active', true)
        .single();

      if (error || !artist) {
        document.getElementById('artistName').textContent = 'Gallery Not Found';
        document.getElementById('artworkGrid').innerHTML = '<div class="empty-gallery">This gallery does not exist or is no longer active.</div>';
        return;
      }

      currentArtist = artist;

      // Track page view
      trackAnalytics(artist.id, 'page_view');

      // Get subscription plan details
      const { data: subscription } = await supabase
        .from('subscriptions')
        .select(`
          *,
          subscription_plans (*)
        `)
        .eq('user_id', artist.id)
        .single();

      currentPlan = subscription?.subscription_plans || { slug: 'free', show_branding: true, social_links: false };

      // Show branding badge and AR helper for free tier
      if (currentPlan.show_branding !== false && currentPlan.slug === 'free') {
        document.getElementById('poweredByBadge').style.display = 'block';
        document.getElementById('arHelper').style.display = 'block';
      }

      // Setup device-aware AR buttons
      setupArButtons();

      // Update page
      document.title = `${artist.gallery_name || artist.full_name} - HiveMind AR`;
      document.getElementById('artistName').textContent = artist.gallery_name || artist.full_name || 'Artist Gallery';

      // Show verified badge for paid users
      const isPaidPlan = currentPlan.slug === 'artist' || currentPlan.slug === 'professional';
      if (isPaidPlan) {
        document.getElementById('verifiedBadge').style.display = 'inline-flex';
      }

      if (artist.location) {
        document.getElementById('artistLocation').textContent = artist.location;
      }

      if (artist.bio) {
        document.getElementById('artistBio').textContent = artist.bio;
      }

      if (artist.avatar_url) {
        const avatar = document.getElementById('artistAvatar');
        avatar.src = artist.avatar_url;
        avatar.style.display = 'block';
      }

      // Artist links
      const linksContainer = document.getElementById('artistLinks');
      if (artist.website) {
        linksContainer.innerHTML += `<a href="${artist.website}" target="_blank">Website</a>`;
      }

      // Banner (only for paid users with custom banner)
      if (artist.banner_url && isPaidPlan) {
        const bannerContainer = document.getElementById('artistBanner');
        const bannerImg = document.getElementById('bannerImage');
        bannerImg.src = artist.banner_url;

        // Apply position and zoom
        const posX = artist.banner_position_x || 50;
        const posY = artist.banner_position_y || 50;
        const zoom = artist.banner_zoom || 100;
        bannerImg.style.objectPosition = `${posX}% ${posY}%`;
        bannerImg.style.transform = `scale(${zoom / 100})`;

        // Apply effects
        let filters = [];
        if (artist.banner_blur > 0) filters.push(`blur(${artist.banner_blur}px)`);
        switch(artist.banner_tint) {
          case 'warm': filters.push('sepia(0.3) saturate(1.2)'); break;
          case 'cool': filters.push('hue-rotate(20deg) saturate(0.9)'); break;
          case 'sepia': filters.push('sepia(0.6)'); break;
          case 'purple': filters.push('hue-rotate(270deg) saturate(0.8)'); break;
        }
        if (filters.length > 0) bannerImg.style.filter = filters.join(' ');

        // Apply darken overlay
        if (artist.banner_darken > 0) {
          const overlay = document.createElement('div');
          overlay.style.cssText = `position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,${artist.banner_darken / 100}); pointer-events: none;`;
          bannerContainer.appendChild(overlay);
        }

        bannerContainer.style.display = 'block';
        document.getElementById('artistHero').classList.add('has-banner');
      }

      // Social links (only show for paid plans with social_links feature)
      const socialContainer = document.getElementById('socialLinks');
      const canShowSocialLinks = currentPlan.social_links || currentPlan.slug === 'artist' || currentPlan.slug === 'professional';

      if (canShowSocialLinks) {
        const socialHtml = [];
        if (artist.instagram_url) socialHtml.push(`<a href="${artist.instagram_url}" target="_blank" class="social-link" title="Instagram">üì∑</a>`);
        if (artist.facebook_url) socialHtml.push(`<a href="${artist.facebook_url}" target="_blank" class="social-link" title="Facebook">üìò</a>`);
        if (artist.twitter_url) socialHtml.push(`<a href="${artist.twitter_url}" target="_blank" class="social-link" title="Twitter/X">üê¶</a>`);
        if (artist.tiktok_url) socialHtml.push(`<a href="${artist.tiktok_url}" target="_blank" class="social-link" title="TikTok">üéµ</a>`);
        if (artist.youtube_url) socialHtml.push(`<a href="${artist.youtube_url}" target="_blank" class="social-link" title="YouTube">‚ñ∂Ô∏è</a>`);
        if (artist.etsy_url) socialHtml.push(`<a href="${artist.etsy_url}" target="_blank" class="social-link" title="Etsy Shop">üõí</a>`);
        socialContainer.innerHTML = socialHtml.join('');
      }

      // Get artworks
      const { data: artworkData } = await supabase
        .from('artworks')
        .select('*')
        .eq('user_id', artist.id)
        .eq('is_active', true)
        .order('sort_order', { ascending: true })
        .order('created_at', { ascending: false });

      artworks = artworkData || [];

      document.getElementById('artworkCount').textContent = artworks.length;

      // Calculate total views
      const totalViews = artworks.reduce((sum, a) => sum + (a.view_count || 0), 0);
      document.getElementById('viewCount').textContent = totalViews;

      if (artworks.length === 0) {
        document.getElementById('artworkGrid').innerHTML = '<div class="empty-gallery">No artworks in this gallery yet.</div>';
        return;
      }

      // Show contact section
      document.getElementById('contactSection').style.display = 'block';

      // Render artworks
      document.getElementById('artworkGrid').innerHTML = artworks.map(artwork => {
        const hasGLB = artwork.glb_url;
        const dimensions = `${artwork.width_inches}" x ${artwork.height_inches}"`;
        const price = artwork.price_usd ? `$${artwork.price_usd.toLocaleString()}` : 'Price on request';

        if (hasGLB) {
          return `
            <div class="artwork-card">
              <div class="artwork-card-wrapper" data-artwork-id="${artwork.id}" data-width-inches="${artwork.width_inches || 24}" data-height-inches="${artwork.height_inches || 24}">
                <model-viewer
                  src="${artwork.glb_url}"
                  poster="${artwork.image_url}"
                  alt="${artwork.title}"
                  ar
                  ar-modes="webxr scene-viewer quick-look"
                  ar-scale="fixed"
                  camera-controls
                  touch-action="pan-y"
                  shadow-intensity="0.3"
                  exposure="1.1"
                  loading="lazy"
                  data-base-glb="${artwork.glb_url}">
                </model-viewer>
                <div class="frame-selector-compact">
                  <button class="frame-btn no-frame selected" data-frame="none" onclick="selectFrameCompact(this, '${artwork.id}', 'none')" title="No Frame"></button>
                  <button class="frame-btn wood-frame" data-frame="wood" onclick="selectFrameCompact(this, '${artwork.id}', 'wood')" title="Wood Frame"></button>
                  <button class="frame-btn black-frame" data-frame="black" onclick="selectFrameCompact(this, '${artwork.id}', 'black')" title="Black Frame"></button>
                  <button class="frame-btn gold-frame" data-frame="gold" onclick="selectFrameCompact(this, '${artwork.id}', 'gold')" title="Gold Frame"></button>
                  <button class="frame-btn white-frame" data-frame="white" onclick="selectFrameCompact(this, '${artwork.id}', 'white')" title="White Frame"></button>
                  <button class="frame-btn silver-frame" data-frame="silver" onclick="selectFrameCompact(this, '${artwork.id}', 'silver')" title="Silver Frame"></button>
                </div>
                <button class="custom-ar-button pulse" onclick="activateAR(this)">
                  View in AR
                </button>
              </div>
              <div class="artwork-info">
                <span class="ar-badge">AR Ready</span>
                <h3>${artwork.title}</h3>
                ${artwork.description ? `<p class="description">${artwork.description}</p>` : ''}
                <div class="artwork-meta">
                  <span class="dimensions">${dimensions}</span>
                  <span class="price">${price}</span>
                </div>
              </div>
              <div class="artwork-actions">
                <button class="btn btn-dark" onclick="inquireAbout('${artwork.id}', '${artwork.title}')">Inquire</button>
              </div>
            </div>
          `;
        } else {
          return `
            <div class="artwork-card">
              <img class="artwork-image" src="${artwork.image_url || '/images/placeholder.png'}" alt="${artwork.title}">
              <div class="artwork-info">
                <h3>${artwork.title}</h3>
                ${artwork.description ? `<p class="description">${artwork.description}</p>` : ''}
                <div class="artwork-meta">
                  <span class="dimensions">${dimensions}</span>
                  <span class="price">${price}</span>
                </div>
              </div>
              <div class="artwork-actions">
                <button class="btn btn-dark" onclick="inquireAbout('${artwork.id}', '${artwork.title}')">Inquire</button>
              </div>
            </div>
          `;
        }
      }).join('');

      // Track page view (one per session)
      trackViews();

      // Add error listeners to model-viewers to detect broken GLBs
      addModelViewerErrorHandlers();
    }

    // Handle model-viewer errors (broken GLBs)
    function addModelViewerErrorHandlers() {
      document.querySelectorAll('model-viewer').forEach(mv => {
        mv.addEventListener('error', (e) => {
          console.error('Model-viewer error for artwork:', mv.closest('.artwork-card-wrapper')?.getAttribute('data-artwork-id'), e);
          const wrapper = mv.closest('.artwork-card-wrapper');
          if (wrapper) {
            // Hide the AR button since the GLB is broken
            const arButton = wrapper.querySelector('.custom-ar-button');
            if (arButton) {
              arButton.style.display = 'none';
            }
            // Hide frame selector since it won't work without valid GLB
            const frameSelector = wrapper.querySelector('.frame-selector-compact');
            if (frameSelector) {
              frameSelector.style.display = 'none';
            }
            // Remove AR Ready badge from artwork info
            const artworkCard = wrapper.closest('.artwork-card');
            const arBadge = artworkCard?.querySelector('.ar-badge');
            if (arBadge) {
              arBadge.textContent = 'AR Unavailable';
              arBadge.style.background = '#6c757d';
            }
          }
        });

        // Also listen for load success to ensure AR button is visible
        mv.addEventListener('load', () => {
          console.log('Model loaded successfully:', mv.getAttribute('src'));
        });
      });
    }

    // Track views
    async function trackViews() {
      const viewedKey = `viewed_gallery_${currentArtist.id}`;
      if (sessionStorage.getItem(viewedKey)) return;

      sessionStorage.setItem(viewedKey, 'true');

      // Increment view count for each artwork
      for (const artwork of artworks) {
        await supabase.rpc('increment_view_count', { artwork_id: artwork.id }).catch(() => {});
      }
    }

    // Select frame from compact selector
    window.selectFrameCompact = async function(button, artworkId, frameType) {
      // Remove selected class from all frame buttons in this artwork card
      const wrapper = button.closest('.artwork-card-wrapper');
      wrapper.querySelectorAll('.frame-btn').forEach(btn => {
        btn.classList.remove('selected');
      });

      // Add selected class to clicked button
      button.classList.add('selected');

      // Store the selection for this artwork
      artworkFrameSelections[artworkId] = frameType;

      const modelViewer = wrapper.querySelector('model-viewer');

      // Store original poster and GLB if not already stored
      if (!originalPosters[artworkId]) {
        originalPosters[artworkId] = modelViewer.getAttribute('poster');
      }
      if (!originalGLBs[artworkId]) {
        originalGLBs[artworkId] = modelViewer.getAttribute('src');
      }

      if (frameType === 'none') {
        // Reset to original poster and GLB
        modelViewer.setAttribute('poster', originalPosters[artworkId]);
        modelViewer.setAttribute('src', originalGLBs[artworkId]);
        console.log('Frame removed, showing original artwork');
      } else {
        try {
          // Show loading state
          button.style.opacity = '0.5';
          console.log(`Starting frame generation: ${frameType} for artwork ${artworkId}`);

          // Get the image source
          let imageSource = originalPosters[artworkId];
          console.log('Original poster URL:', imageSource);

          const framedImageUrl = await window.frameGenerator.addFrameToImage(imageSource, frameType);
          console.log('Framed poster image generated successfully');

          // Update model-viewer poster
          modelViewer.setAttribute('poster', framedImageUrl);

          // Get artwork dimensions
          const widthInches = parseFloat(wrapper.getAttribute('data-width-inches')) || 24;
          const heightInches = parseFloat(wrapper.getAttribute('data-height-inches')) || 24;

          console.log(`Generating framed GLB for ${widthInches}" x ${heightInches}" artwork`);

          // Generate framed GLB for AR
          const cacheKey = `${artworkId}_${frameType}`;
          if (!framedGLBs[cacheKey]) {
            const framedGLBUrl = await window.frameGenerator.generateGLBFromImage(framedImageUrl, widthInches, heightInches);
            framedGLBs[cacheKey] = framedGLBUrl;
            console.log('Framed GLB generated successfully');
          }

          // Update model-viewer src to use framed GLB
          modelViewer.setAttribute('src', framedGLBs[cacheKey]);

          // Restore button
          button.style.opacity = '1';

          // Show success notification
          const notification = document.createElement('div');
          notification.textContent = `${frameType.charAt(0).toUpperCase() + frameType.slice(1)} frame applied!`;
          notification.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(102, 126, 234, 0.95); color: white; padding: 12px 24px; border-radius: 8px; z-index: 10000; font-size: 14px;';
          document.body.appendChild(notification);
          setTimeout(() => notification.remove(), 2000);

          console.log(`${frameType} frame applied to artwork ${artworkId}`);
        } catch (err) {
          console.error('Frame generation failed:', err);
          console.error('Error details:', err.message, err.stack);
          button.style.opacity = '1';

          // Show error notification
          const notification = document.createElement('div');
          notification.textContent = `Frame generation failed: ${err.message}`;
          notification.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(220, 53, 69, 0.95); color: white; padding: 12px 24px; border-radius: 8px; z-index: 10000; font-size: 14px;';
          document.body.appendChild(notification);
          setTimeout(() => notification.remove(), 3000);

          // Fallback to no frame
          artworkFrameSelections[artworkId] = 'none';
          button.classList.remove('selected');
          wrapper.querySelector('.frame-btn.no-frame').classList.add('selected');
          modelViewer.setAttribute('poster', originalPosters[artworkId]);
          modelViewer.setAttribute('src', originalGLBs[artworkId]);
        }
      }

      // Stop event propagation
      event?.stopPropagation();
      return false;
    };

    // Device detection
    function isMobileDevice() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
             (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    }

    // Setup AR buttons based on device
    function setupArButtons() {
      const arButtons = document.querySelectorAll('.custom-ar-button');
      const isDesktop = !isMobileDevice();

      arButtons.forEach(button => {
        if (isDesktop) {
          // Add desktop-specific styling and tooltip
          button.classList.add('desktop-mode');
          button.innerHTML = `
            View in AR üì±
            <span class="ar-desktop-tooltip">Open this page on your phone to use AR</span>
          `;
        }
      });
    }

    // Activate AR function
    window.activateAR = function(button, event) {
      const wrapper = button.closest('.artwork-card-wrapper');
      const modelViewer = wrapper.querySelector('model-viewer');
      const artworkId = wrapper.getAttribute('data-artwork-id');

      // Check if on desktop
      if (!isMobileDevice()) {
        // Show helpful message for desktop users
        const currentUrl = window.location.href;
        const message = `AR viewing requires a mobile device.\n\nOpen this link on your phone:\n${currentUrl}`;

        // Try to copy to clipboard
        if (navigator.clipboard) {
          navigator.clipboard.writeText(currentUrl).then(() => {
            alert(message + '\n\n(Link copied to clipboard!)');
          }).catch(() => {
            alert(message);
          });
        } else {
          alert(message);
        }
        return false;
      }

      if (modelViewer && modelViewer.tagName === 'MODEL-VIEWER') {
        const selectedFrame = artworkFrameSelections[artworkId] || 'none';
        console.log('Launching AR with selected frame:', selectedFrame);

        // Track AR view
        if (currentArtist) {
          trackAnalytics(currentArtist.id, 'ar_view', artworkId);
        }

        // Launch AR directly
        try {
          modelViewer.activateAR();
        } catch(err) {
          console.error('AR activation failed:', err);
          alert('AR activation failed. Please try again.');
        }

        return false;
      }
    };

    window.inquireAbout = function(artworkId, artworkTitle) {
      document.getElementById('contactSubject').value = `Inquiry about: ${artworkTitle}`;
      document.getElementById('contactArtworkId').value = artworkId;
      showContactModal();
    };

    window.showContactModal = function() {
      document.getElementById('contactModal').classList.add('active');
    };

    window.hideContactModal = function() {
      document.getElementById('contactModal').classList.remove('active');
    };

    window.handleContact = async function(event) {
      event.preventDefault();

      const name = document.getElementById('contactName').value.trim();
      const email = document.getElementById('contactEmail').value.trim();
      const subject = document.getElementById('contactSubject').value.trim();
      const message = document.getElementById('contactMessage').value.trim();
      const artworkId = document.getElementById('contactArtworkId').value || null;
      const submitBtn = document.getElementById('contactSubmitBtn');
      const errorEl = document.getElementById('contactError');
      const successEl = document.getElementById('contactSuccess');

      errorEl.textContent = '';
      successEl.textContent = '';

      submitBtn.disabled = true;
      submitBtn.textContent = 'Sending...';

      try {
        const { error } = await supabase
          .from('messages')
          .insert({
            artist_id: currentArtist.id,
            artwork_id: artworkId,
            sender_name: name,
            sender_email: email,
            subject: subject,
            message: message
          });

        if (error) throw error;

        // Track inquiry
        trackAnalytics(currentArtist.id, 'inquiry', artworkId);

        successEl.textContent = 'Message sent! The artist will respond to your email.';
        document.getElementById('contactForm').reset();

        setTimeout(() => {
          hideContactModal();
          successEl.textContent = '';
        }, 3000);

      } catch (err) {
        console.error('Error:', err);
        errorEl.textContent = err.message || 'Failed to send message. Please try again.';
      }

      submitBtn.disabled = false;
      submitBtn.textContent = 'Send Message';
    };

    // Initialize
    loadGallery();
  </script>

  <script>
    function toggleMobileNav() {
      const navLinks = document.getElementById('navLinks');
      navLinks.classList.toggle('active');
    }

    // Close mobile menu when clicking a link
    document.addEventListener('DOMContentLoaded', function() {
      const navLinks = document.querySelectorAll('.nav-links a');
      navLinks.forEach(link => {
        link.addEventListener('click', () => {
          const menu = document.getElementById('navLinks');
          menu.classList.remove('active');
        });
      });
    });
  </script>
</body>
</html>
